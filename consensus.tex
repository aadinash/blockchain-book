\chapter{Blockchains are Secure}

{\color{red}
\begin{itemize}
\item The backbone model in the static difficulty setting
\item Interactive Turing machines
\item The environment
\item Synchronous time: The integer round
\item The theoretical network model
\item The rushing adversary
\item The Sybil adversary
\item The parties: The parameters $n$, $t$
\item The honest majority assumption: The parameter $\delta$
\item Mining modeled as a Random Oracle: The parameter $q$
\item The backbone protocol
\item Validating blocks
\item The longest chain rule
\item Mining
\item The Chain Growth property: The parameters $s$ and $\tau$
\item The Common Prefix property: The parameter $k$
\item The Chain Quality property: The parameters $\ell$ and $\mu$
\item Ledger liveness: The parameter $u$
\item Ledger safety
\item Proof of liveness from Chain Growth and Chain Quality
\item Calculation of the liveness parameter $u$
\item Proof of safety from Common Prefix
\item Successful rounds and uniquely successful rounds
\item The probabilistic treatment using the random variables $X$, $Y$, and $Z$
\item Probabilities of success and failure
\item Chernoff bound intuition
\item Chernoff bound theorem for binomial distributions: The parameter $\epsilon$
\item Convergence opportunities
\item Uniquely successful rounds avoid fan-out attacks unless matched by adversarial mining power
\item The equal computational split model
\item The world is a good place: Typical executions
\item The distance between $X$ and $Y$: The block production parameter $f$
\item The distance between $Y$ and $Z$: The Chernoff error parameter $\epsilon$
\item The Chernoff waiting time $\lambda$
\item The balancing equation $3\epsilon + 3f < \delta$
\item Calculating the relationship between adversarial power $(n, t)$, network diameter, and block production rate
\item The Typicality Theorem
\item The Chain Growth Lemma
\item A proof of the Chain Growth property, calculation of the parameters $s=\lambda$ and $\tau=(1 - \epsilon)f$
\item The Chain Slowness Lemma
\item The Pairing Lemma
\item A proof of the Common Prefix property
\end{itemize}
}

\section*{Problems}

\begin{enumerate}
  \item Consider an execution under a minority adversary and good parameters such that
        the Common Prefix property is typically preserved for some parameter $k$. Now,
        under the same parameters, you, the adversary, are given a special power: You
        can change the response to exactly \emph{one} fresh random oracle query by the
        honest parties. You can change the query adaptively (you can decide whether you
        want to change it, or not, once you see the query). You cannot change an old query
        for which the random oracle already has a cached entry. After you change one response,
        the random oracle caches your response and responds consistently in the future.
        How would you use this ability to break Common Prefix for the same parameter $k$?
\end{enumerate}
