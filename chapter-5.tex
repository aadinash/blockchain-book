\chapter{Blocks and Chains \small{\textsf{DRAFT}}}\label{chapter:blocks}

\section{The Network Delay}

In the last chapter, we created a monetary system in which participants can issue transactions
and transfer money between one another while maintaining scarcity. We ensured participants can
only spend their own money by using an unforgeable signature scheme to authenticate transactions
that everyone verified. By gossiping transactions on the network, every participant assembled
them, upon verification, into a transaction graph, and reading the UTXO set of that transaction
graph enabled participants to determine \emph{who owns what}.
Furthermore, we made that transaction graph append-only. Our intuition is that, since every
transaction is gossiped, everyone will eventually arrive at the same transaction graph,
and the population will reach consensus on the UTXO set, even if some transactions take
a moment to arrive to distant parts of the network. Note that, it doesn't matter to us if
different honest parties observe transactions arriving on the network in different order,
as long as all the parties compute the same UTXO set. This is the only thing that's important
to determine \emph{who owns what}. If two honest nodes accept the same set of transactions,
even if they have processed them in different order, they will arrive at the same transaction
graph and the UTXO set computed by them will be the same.

Of course, if a transaction is delayed while in transit on the network \emph{for ever}, some nodes
will not receive it and they will not be in consensus with the rest of the network, but this
contradicts our non-eclipsing assumption that we introduced in
Chapter~\ref{chapter.untrusty-world}. To make our intuition more precise, let us quantify how
long it takes for a message to reach the whole network when it is broadcast by any party.
We call this the \emph{network delay parameter}.

\glsxtrnewsymbol[description={network delay}]{delay}{$\Delta$}\glsadd{delay}
\begin{definition}[Network Delay]\index{Network Delay}
  The \emph{network delay parameter} $\Delta$ measures the maximum time it takes
  for a message to travel from one honest party to every other honest party on the
  network.
\end{definition}

Because honest parties gossip adversarial messages, this network delay ensures that
even adversarial messages make it across the network within $\Delta$ time. That is,
if an honest party receives an adversarial message at some point in time, then every
honest party will see the same adversarial message within time $\Delta$.

Now we can express our intuition that nodes reach consensus more precisely:
While some transactions may be delayed up to $\Delta$ time,
if no transactions are broadcast for a time of $\Delta$, everyone's transaction
graph will converge to be the same, and the UTXO set will be shared among along
all honest parties. Unfortunately, this intuition is misguided, and things are not
that simple. Things break down when double spend transactions are introduced
by the adversary.

\section{The Double Spend}\index{Double Spend}

Let's try to understand the double spending problem a little more carefully. Eve
receives $1$ unit of money from Alice through a transaction $\tx_1$ as illustrated in
Figure~\ref{fig.double-spend}. The transaction $\tx_1$ was created honestly by Alice
and has one input of $1$ unit coming from Alice, and one output of $1$ unit paying
Eve's public key. Eve now creates two transactions: The first transaction, $\tx_2$
consumes the single output of $\tx_1$ and pays $1$ unit back to Alice. The second transaction,
$\tx_2'$ also consumes the single output of $\tx_1$ and pays $1$ unit, this time to Eve.

Suppose that two other parties, Charlie and Dave, have already seen $\tx_1$ on the network,
but have not yet received either of $\tx_2$ or $\tx_2'$. If Charlie receives $\tx_2$, he
will accept this transaction as valid. The transaction's input contains an outpoint that
points to an element of the UTXO set in his view, since the output of $\tx_1$ has not been
previously spent. Furthermore, the transaction contains a valid signature by Eve created
with the correct public key, and it satisfies the Conservation Law. Upon accepting $\tx_2$,
Charlie updates his UTXO set, removing the output of $\tx_1$ and adding the output of
$\tx_2$ to it. If Charlie now receives $\tx_2'$, he will reject this transaction, as
it is spending from an output that is not in the UTXO set in his view.

On the contrary, Dave receives $\tx_2'$ first, and $\tx_2$ after. When Dave receives $\tx_2'$,
he considers this a valid transaction, because it is spending from the UTXO set in his view.
Dave, contrary to Charlie, believes that the output of $\tx_1$ is still in the UTXO set.
Dave then updates his UTXO set, removing the output of $\tx_1$ and adding the output
of $\tx_2'$ to it.

At this point Charlie's and Dave's view are in disagreement. This is a problem. If Alice has
also received $\tx_2$ prior to $\tx_2'$, she will justifiably believe that Eve paid her.
While Charlie will accept Alice's money, because it is in his UTXO set, Dave will not accept
Alice's money. We have arrived at a situation where Alice's money is not acceptable to everyone.
We have lost consensus on \emph{who owns what}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6 \columnwidth,keepaspectratio]{figures/double-spend.pdf}
    \caption{A double spend transaction. Alice paid Eve $1$ unit through $\tx_1$, but Eve spent it in both $\tx_2$ and in $\tx_2'$,
             which have different recipients.}
    \label{fig.double-spend}
\end{figure}

\section{Simple Ideas Don't Work}\label{sec:simple-ideas}

Let us consider three simple ideas to resolve the double spending problem that first come to mind.
Sadly, these ideas won't work.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4 \columnwidth,keepaspectratio]{figures/simple-idea-1.pdf}
    \caption{The first idea is unviable because it allows the
    adversary to retroactively invalidate an earlier transaction much later. Here, $\tx_2'$
    is initially withheld, but broadcast much later, causing an invalidation to the earlier
    $\tx_2$ transaction.}
    \label{fig.simple-idea-1}
\end{figure}

\noindent
\textbf{Idea 1: Reject double spends altogether.} Honest parties never double spend. Since the adversary is the only one
creating double spends, why do we need to provide any assurances? We can opt to simply invalidate that
money. We add the following rule to our protocol:

\begin{quote}
If you see a transaction that is a double-spend,
then consider \emph{all} of the transaction outputs that pertain to the double spend transactions invalid.
\end{quote}

This approach is problematic. The reason is that the adversary can retroactively take back
a payment: She initially broadcasts $\tx_2$ to the network paying Alice, but keeps $\tx_2'$ withheld,
as illustrated in the timeline of Figure~\ref{fig.simple-idea-1}.
Alice, like everyone else, observes $\tx_2$ on the network, but not $\tx_2'$. She thinks this is
a normal transaction and accepts the payment. In exchange for this payment, Alice provides a service
to Eve: she serves her coffee. At a later time, Eve has enjoyed the coffee and has departed from Alice's
establishment. At this point, Eve broadcasts $\tx_2'$, a double spend of $\tx_2$. Suddenly, everyone
on the network considers both $\tx_2$ and $\tx_2'$ invalid. Alice's money is gone. Therefore, we cannot
adopt this construction.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.325 \columnwidth,keepaspectratio]{figures/simple-idea-2.pdf}
    \caption{The second idea is unviable because parties
    have views in disagreement about transaction order. Here, Charlie believes $\tx_2$
    precedes $\tx_2'$, whereas Dave believes $\tx_2'$ precedes $\tx_2$.}
    \label{fig.simple-idea-2}
\end{figure}

\noindent
\textbf{Idea 2: Accept the first transaction seen.} As we saw, two different honest parties can disagree in
the order in which two transactions arrived on the network. The situation is illustrated in
Figure~\ref{fig.simple-idea-2}. Therefore, the following simple construction does not work:

\begin{quote}
  Among double spending transactions, accept the first, and reject every subsequent transaction.
\end{quote}

However, we now note that these two transactions must be broadcast
to honest parties in close succession, and in particular within time $\Delta$. If the adversary
were to reveal $\tx_2$ to Charlie first, but then wait for more than $\Delta$ time until she revealed
$\tx_2'$ to Dave, then Charlie would have gossiped $\tx_2$ and Dave would have receive it within $\Delta$
and prior to seeing $\tx_2'$. In that case, Charlie and Dave would be in agreement.
In order for the adversary to cause disagreement, she must broadcast the two double spending
transactions to two different honest parties within time $\Delta$ of each other. Yet, this is
simple for an adversary to do, so we cannot adopt this construction either.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45 \columnwidth,keepaspectratio]{figures/simple-idea-3.pdf}
    \caption{The third idea is unviable because parties
    disagree about whether $\tx_2$ and $\tx_2'$ have arrived within time $u$,
    and follow different policies. Here, Charlie rejects both transactions, whereas
    Dave accepts $\tx_2$ and rejects $\tx_2'$.}
    \label{fig.simple-idea-3}
\end{figure}

\noindent
\textbf{Idea 3: Reject double spends within $u$.} Why don't we combine ideas 1 and 2? We saw that
Idea 1 is problematic because it allows the adversary to retroactively take back a transaction after
a long time into the future. We also saw that Idea 2 is problematic because it allows an adversary to
cause disagreement when two transactions are broadcast in close succession. This creates a natural
new construction idea:

\begin{quote}
Upon seeing a transaction, wait for some time $u \geq \Delta$. If a double spend
appears within the window $u$, reject all double spending transactions. However, if $u$ has passed and we have
not seen any double spends, accept the single transaction that we have seen. If a double spend appears in
the future, just reject that one.
\end{quote}

At first sight, this third idea seems to work: After time $u$ has passed, either the money is accepted or not.
The adversary cannot walk away as she did against Idea 1. If the adversary broadcasts two conflicting
transactions within $\Delta$ time, as she did against Idea 2, they will both be rejected. It won't matter
that different parties saw them in different order.

Sadly, on closer inspection, this idea does not work,
either. The strategy of the adversary is now to cause disagreement between Charlie and Dave with
regards to \emph{whether or not} the two transactions appeared within time $u$. The problematic situation
is illustrated in Figure~\ref{fig.simple-idea-3}. The adversary initially broadcasts $\tx_2$
to both Charlie and Dave. Both Charlie's and Dave's clocks start ticking to measure the time $u$.
Right before time $u$ hits, the adversary broadcasts $\tx_2'$ to Charlie. Now, Charlie has seen
a double spend within time $u$, and so he rejects both $\tx_2$ and $\tx_2'$. He also rebroadcasts
$\tx_2'$ to Dave, but this message will require time $\Delta$ to reach Dave. In the meantime,
time $u$ has passed, and Dave accepts $\tx_2$. When $\tx_2'$ arrives on Dave's end, Dave has
already accepted $\tx_2$ and now rejects $\tx_2'$. Now Charlie and Dave are in disagreement:
Dave thinks $\tx_2$ is valid, whereas Charlie thinks $\tx_2$ is invalid.

Try to think of more simple ideas to resolve this ordering issue. You'll see that
none of them will work. For example, placing a timestamp within a transaction to ensure
that every honest party simultaneously applies a transaction doesn't work, either (why?).
We'll need to invent heavier artillery to attack this problem.

\section{Ledgers}

Even though honest parties receive transactions in a different order on the network,
we would like to have them coordinate with one another to report them in the same
order. Each honest party will report a \emph{ledger}, an ordered sequence of transactions.
This ledger will not necessarily contain the transactions in the order they were
received from the network. It may also not immediately report some transaction as
soon as it is received from the network, but, akin to Idea 3 of Section~\ref{sec:simple-ideas},
it may need to delay reporting it on its ledger for a bit.
By reading that ledger reported by an honest party one transaction at a time from left to right,
we can reconstruct the transaction graph and arrive at the UTXO set. If the honest parties
agree on their reported ledgers, they will agree on the UTXO set. We'll therefore concern
ourselves with the question on whether we can achieve consensus among the ledgers reported
by honest parties.

We will soon figure out what each honest party should do internally in order to produce
a ledger that is consistent with every other honest party, but before we get to \emph{how}
to do that, let us first more clearly articulate what exactly it is that we want to achieve.

We wish to build an honest party construction $\Pi$ which we call the \emph{full node}\index{Full node}.
This will be a piece of code which will be identically executed by all honest parties.
It will implement peer discovery, the
gossiping network communication to exchange messages on the network, and so on. In
addition, we'll make $\Pi$ expose two functionalities: A
\emph{write} functionality, and a \emph{read} functionality. The \emph{write} functionality
accepts a brand new transaction. This transaction is
broadcast and gossiped to every other party on the network by the full node.
The \emph{read} functionality returns a ledger of transactions.
These functionalities are used by the \emph{wallet}. Together, the full node and
the wallet constitute the software that is running on the human user's machine.
The human user only interacts with the wallet, while the full node sits on the backend.

The wallet is a piece of software that is capable of creating and signing
new transactions to make payments as instructed by the user. The wallet also shows
whether a payment was received, and displays the balance of the user. These functionalities
are made possible by having access to the \emph{write} and \emph{read} functionalities
exposed by the full node. The \emph{write} functionality is what the wallet uses to
broadcast a new transaction into the network, whereas the \emph{read} functionality
allows the wallet to obtain a ledger that it can then use to obtain the UTXO set
in order to display whether a payment has been completed and to calculate the user
balances. This architecture is illustrated in Figure~\ref{fig.wallet-fullnode-architecture}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.65 \columnwidth,keepaspectratio]{figures/wallet-fullnode-architecture.pdf}
    \caption{The human user interacts with the wallet. The wallet interacts with the full node
    by invoking its \emph{write} and \emph{read} functionalities. The full node interacts with the network.}
    \label{fig.wallet-fullnode-architecture}
\end{figure}

We'll have more to say about the wallet portion in the next chapters. For now,
let us focus on how to build the full node.

Our goal will be to have all the honest full nodes agree on the ledgers they are reporting
when their \emph{read} functionality is invoked. That way, everyone will arrive at the same
UTXO set and agree \emph{who owns what}.

\begin{definition}[Ledger]
    A \emph{ledger} of an honest party $P$ reported at time $r$, denoted $L^P_r$ is
    a finite \emph{sequence of transactions} returned when the honest party $P$ invokes
    the \emph{read} functionality of its honest protocol $\Pi$.
\end{definition}

We take note here that ledgers are dependent on both $P$ and $r$. It is nonsensical to
speak about ``the ledger'' without specifying \emph{who} and \emph{when}. While these
parameters may sometimes be implicit, it is imperative that we understand what we are
talking about. Ignoring the \emph{who} and the \emph{when} of the ledger, and speaking
about ``the ledger'' as if it is a global view, is a common cause for confusion and
misconception. As we saw in the previous section, the ledgers of different honest
parties may be in disagreement, and there might not even be a well-defined global
ledger.

We want the ledgers reported by honest parties to have two \emph{virtues}. We give
an intuitive definition of these virtues now, but we will return to define them
more formally in Chapter~\ref{chapter:earnest2}.

\begin{definition}[Safety]
    For any two honest parties, their reported ledgers should be equal.
\end{definition}

\begin{definition}[Liveness]
    If an honest party \emph{writes} a transaction into its ledger, then this
    transaction appears in the ledgers of all honest parties ``soon''.
\end{definition}

Let us think what these virtues are saying. If a ledger has \emph{safety},
then \emph{bad things don't happen}. We do not run into double-spend situations,
or into disagreements about \emph{who owns what}. If a ledger has \emph{liveness},
then \emph{good things happen}. When an honest party attempts to issue a transaction,
this transaction actually does take place.

It is easy to build a protocol that has \emph{safety} or \emph{liveness}, but not
both together.

\noindent
\textbf{Safe but not live.} A safe but not live protocol acts as follows.
Whenever the \emph{read} functionality is invoked, it returns the empty sequence of
transactions as the ledger. Whenever the \emph{write} functionality is invoked, it
ignores the transaction being written. It never reads or writes anything from the
network. Because the \emph{read} functionality always returns the same thing,
safety is trivially satisfied. Liveness, however, is not satisfied. When an honest
party attempts to make a transaction, it is never reported in the ledgers of other
honest parties.

\noindent
\textbf{Live but not safe.} A live but not safe protocol acts as follows.
Each honest party begins with an empty initial ledger. Whenever the \emph{write}
functionality is invoked with a transaction, this transaction is appended to the
local ledger and broadcast to the network. When a new transaction is received from the
network, it is gossiped to the rest of the network and appended to the local ledger.
The \emph{read} functionality returns the local ledger. This protocol is live
because every honest transaction makes it to the ledger of every honest party.
However, it is not safe, because transactions are reported on the ledgers in the
order they are received from the network, and this order may be different for
different parties.

Our design goal for the rest of this book will be to build protocols that
are \emph{both} safe and live simultaneously.

\section{Rare Events}

\section{The Block}

We have introduced a moderately hard problem that forces the adversary to spread out her
tickets in time by more than $\Delta$. But how do we associate tickets with transactions?
We cannot just require the adversary to send a ticket together with a transaction.
The adversary may reuse a ticket multiple times, or may use a ticket together with one transaction
when communicating with one party and the same ticket with another transaction when
communicating with another party. We need to somehow tie the ticket together with a
transaction so that a ticket is only usable for a particular transaction.
To do this, we set $B = \tx \conc \ctr$ and require the ticket to satisfy $H(B) \leq T$,
as before, where $\tx$ is the transaction we want the ticket to be tied to.
The revised mining process is illustrated in Algorithm~\ref{alg.mine-tx}.
Now, upon receiving a transaction/ticket pair, we can check that the ticket corresponds
to the particular transaction. Furthermore, if the adversary attempts to replace the
transaction within $B$ with a different one, then this will cause $H(B)$ to change.
The value $H(B)$ is \emph{committing} to a particular transaction; changing the transaction
changes the value $H(B)$ in a way that cannot be predicted. If she changes the transaction,
this will invalidate the proof-of-work and the adversary will have to perform yet another
exhaustive search to find a new ticket.

\import{./}{algorithms/alg.mine-tx}

We've solved one problem, but have introduced another: If we require one ticket per transaction
for the adversary, then we must do the same for the honest parties. This means that at most one
transaction can be executed every $\Delta$. If the honest party wants to issue multiple transactions,
this will take a long time, and liveness will deteriorate. In order to solve this, we will \emph{bundle}
transactions together into a sequence $\overline{x} = (\tx_1, \tx_2, \ldots, \tx_n)$, and place
this within the ticket, setting $B = \overline{x} \conc \ctr$.
Instead of each ticket being associated with \emph{one} transaction, each ticket
is now associated with multiple. Such a ticket is known as a \emph{block}~\index{Block}. 
The modified mining algorithm is illustrated in Algorithm~\ref{alg.mine-xbar}. Here,
we've just replaced $\tx$ with $\overline{x}$. Now each honest party can issue as many transactions
as he wants in one go, as long as he is able to mine one block.

\import{./}{algorithms/alg.mine-xbar}

A natural question now arises: If we've bundled multiple transations together into one block,
hasn't the double spending problem resurfaced? The answer is \emph{no}, because, in order to
verify a block, all the transactions must be sent together in the bundle. As part of our block
validation rule, we will require that there are no conflicting transactions within the payload
$\overline{x}$ of a block. If $\overline{x}$ contains two mutually double spending transactions,
the whole block will be rejected. Blocks are either accepted or rejected as a whole. We will not
partially accept transactions within a block.

Double spending transactions can still appear in different blocks, but the moderate difficulty
of the proof-of-work puzzle ensures that blocks are produced sufficiently far apart. Like
transactions, blocks are gossiped over the network. If two blocks are transmitted at least
$\Delta$ time apart, then the first will arrive at the doorstep of every honest party before
the second. The second block, containing a transaction that double spends a transaction in the
first block, can then be rejected by all honest parties. Again, here, the whole block will be
rejected, not just the particular pathological transaction.

\section{The Mempool}

Even though we allow each mining party to include many transactions into their own blocks,
honest parties are still encumbered with the responsibility to mine a block before they can
get their transactions accepted by others. This wait time may still be long and this scheme
is not very good for liveness. Worse yet, some honest parties may have large computational
power, while other honest parties may have smaller computational power, and so the block
generation for each honest party might be vastly different. It would be nice if we didn't
tie the liveness of each honest party to that particular party's computational power.

Towards that purpose, we design the system as follows: A transaction can still be issued
independently of a block and broadcast to the network. The transaction is gossiped until
it reaches everyone on the network as usual. However, the transaction is placed into a
temporary waiting area called the \emph{mempool}~\index{Mempool}, ensuring double spends are
resolved one way or another (any of the simple ideas we discussed previously can be used as
strategies to resolve double spends).
Each honest party maintains their own mempool of transactions that are still in limbo.
Because the double spending problem has not yet been solved by finding a block, different
honest parties may disagree about what their mempool looks like.
However, each mempool is independently locally consistent.
When an honest party tries to mine a block,
he includes all the transactions in his mempool into this block. This has the benefit
that, whenever \emph{any} honest party finds a block, \emph{all} pending honest tranasctions
are included in that block, as long as they have been issued more than $\Delta$ time ago.

When a transaction makes it into a block, we term the transaction
\emph{confirmed}~\index{Confirmation}. An honest party invokes the \emph{read} functionality
of its ledger, only confirmed transactions are reported. This ensures that ledgers
are consistent, salvaging safety.

\section{Blocks and Blockchains}

\subsection{Blocks}

\subsection{Proof of Work and Mining}

\begin{definition}[Proof-of-Work Equation]
  $H(B) \leq T$
\end{definition}

Here, $T$ is called the target. In order to solve the Proof-of-Work equation, one would have to find a value of $B$ such that $H(B) \leq T$.

\begin{definition}[Random Oracle Model]
  Output of $H$ is distributed uniformly at random.
\end{definition}

Under the Random Oracle Assumption, notice that the time it would take to find a bruteforce solution to a Proof-of-Work equation depends on the value of $T$. When $T$ is larger, it would be easier to find $B$ such that $H(B) \leq T$, and vice versa. In particular, $Pr[H(B) \leq T] = \frac{T}{2^{\kappa}}$ for any arbitrary $B$.

In the network, $T$ is fixed and hard-coded for honest parties. The value is chosen such that the time it takes for a node in the network to find a solution to the Proof-of-Work equation is around $\Delta$.

Now, notice that if we allow honest parties to pick whatever $B$ they want, then as soon as the first valid value of $B$ is found, each node can just trivially reuse that value instantaneously, and safety is lost again. As such, in the network, we require that $B = \delta||\Bar{x}||ctr$, where $||$ means concatenation and where $\delta$ is the hash of the previous block $H(B')$. Both $\delta$ and $\Bar{x}$ are fixed, and $ctr$ is a number to be found that solves the Proof-of-Work equation. In other words, when nodes are trying to solve the Proof-of-Work equation, they are trying different values of $ctr$ until finding a satisfactory one. The time it takes the first node to find a satisfactory $ctr$ for their block will be around $\delta$. The process of finding a bruteforce solution to the Proof-of-Work equation is called mining.

\subsection{Blockchains}

The previous block hash, $\delta$, is a part of $B$ because we want to ensure "freshness", which means that only blocks that are recently created should be able to be broadcasted. Consider the scenario where an adversary mines multiple blocks, but does not broadcast them immediately. Then, at a later point in time, the adversary broadcast all of these blocks at the same time. Since there is not a $\Delta$ interval between the time these blocks are broadcasted, the problem of double spend arises again. There could be disagreements in the ledgers of the honest nodes. In order to prevent this, we require each block to point to the most recent known block. By including $\delta$ as a part of $B$, we ensure that blocks that were mined beforehand are no longer valid, since the adversary could not have predicted $\delta$ before the most recent block was broadcasted. As a result, we can guarantee that blocks will be roughly be broadcasted in regular time intervals. Since blocks are all connected to each other in this way, this chain of block is called the \emph{blockchain}.


\subsection{Genesis Block}

The Genesis Block is the first block in a blockchain. It contains real world data to anchor time, in order to ensure that it is impossible to pre-mine. If the hash of the Genesis Block is known before it is broadcasted, then the adversary could pre-mine multiple blocks beforehand (before the network is even available to the rest of the world). Then, when the Genesis Block is broadcasted, the adversary would be able to broadcast multiple blocks within a short time span. Hence, it is necessary for the Genesis Block to contain real world data to anchor time. For example, Bitcoin genesis block quotes the January 3  2009 The Times headline.

\begin{figure}[H]
    \centering
    \pgfplotsset{compat=1.15}



\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt

\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
%uncomment if require: \path (0,165); %set diagram left start at 0, and has height of 165

%Shape: Rectangle [id:dp6459725379232777]
\draw  [fill={rgb, 255:red, 255; green, 183; blue, 183 }  ,fill opacity=1 ] (132,36) -- (172.53,36) -- (172.53,80.09) -- (132,80.09) -- cycle ;
%Shape: Rectangle [id:dp7451543919622989]
\draw  [fill={rgb, 255:red, 255; green, 183; blue, 183 }  ,fill opacity=1 ] (222,36) -- (262.53,36) -- (262.53,80.09) -- (222,80.09) -- cycle ;
%Shape: Rectangle [id:dp4942977774139823]
\draw  [fill={rgb, 255:red, 255; green, 183; blue, 183 }  ,fill opacity=1 ] (312,35) -- (352.53,35) -- (352.53,79.09) -- (312,79.09) -- cycle ;
%Shape: Rectangle [id:dp8525801453597799]
\draw  [fill={rgb, 255:red, 255; green, 183; blue, 183 }  ,fill opacity=1 ] (402,36) -- (442.53,36) -- (442.53,80.09) -- (402,80.09) -- cycle ;
%Shape: Rectangle [id:dp16781400895186005]
\draw  [fill={rgb, 255:red, 255; green, 183; blue, 183 }  ,fill opacity=1 ] (492,36) -- (532.53,36) -- (532.53,80.09) -- (492,80.09) -- cycle ;
%Straight Lines [id:da27296871485376917]
\draw    (172.73,56.09) -- (219.73,56.09) ;
\draw [shift={(221.73,56.09)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da8965885073779516]
\draw    (262.73,56.09) -- (309.73,56.09) ;
\draw [shift={(311.73,56.09)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da16101344176853494]
\draw    (352.73,55.09) -- (399.73,55.09) ;
\draw [shift={(401.73,55.09)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;
%Straight Lines [id:da6603043582779935]
\draw    (442.73,54.09) -- (489.73,54.09) ;
\draw [shift={(491.73,54.09)}, rotate = 180] [color={rgb, 255:red, 0; green, 0; blue, 0 }  ][line width=0.75]    (10.93,-3.29) .. controls (6.95,-1.4) and (3.31,-0.3) .. (0,0) .. controls (3.31,0.3) and (6.95,1.4) .. (10.93,3.29)   ;

% Text Node
\draw (132,83.09) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\scriptsize Genesis}};
% Text Node
\draw (404,83.09) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\scriptsize Block B'}};
% Text Node
\draw (494,83.09) node [anchor=north west][inner sep=0.75pt]   [align=left] {{\scriptsize Block B}};


\end{tikzpicture}

    \caption{To mine block B, the miner runs the Proof of Work Equation with B = $H(B')||\Bar{x}||ctr$}
    \label{fig:my_label}
\end{figure}


\subsection{Honest Party Block Generation Algorithm}

Putting it all together, an honest party (which we can assume to be every honest node in the network for now) follows the following algorithm to create a valid block. First, it collects any amount of transactions from the network and add them to a mempool, which is a set of validated but unconfirmed transactions \footnote{The number of transactions it collects will be formalized later}. Then, it writes $B = \delta||\Bar{x}||ctr$, and then solves the Proof-of-Work Equation. In other words, it finds a value of ctr (which is also known as the nonce) such that $H(B) \leq T$. If the honest party is successful, it will broadcast the mined block to the network. Otherwise, if another block has been found and received by the honest party first, it will validate the new block, update it's UTXO by removing all the transactions that were spent in the newest block, and update the freshest block in its memory. As such, $B$ would necessarily change, and the honest party will have to solve a new Proof-of-Work equation.

\section{Problems}
TBD

\section{Further Reading}

Proof-of-Work was invented long before blockchains, in 1992, by Cynthia Dwork and Moni Naor
in their seminal paper \emph{Pricing via Processing or Combatting Junk Mail}~\cite{pow} published
in CRYPTO '92.